## 도메인

소프트웨어로 구현할 문제 영역

<br>

## 도메인 모델

(도메인) 개념 모델 != (기술) 구현 모델

- 개념 모델 : 순수하게 문제를 분석한 결과물
  
- 구현 모델: 트랜잭션 처리, 성능 등 구현 기술을 고려한 모델

개념 모델 처음부터 완벽한 도메인 표현 불가능
소프트웨어 개발하는 동안 개발자와 관계자들은 해당 도메인을 더 잘 이해하게 됨

⇒ 모델 보완/변경 발생

따라서 아래와 같은 과정을 거쳐 모델을 발전시켜야 함

1. 요구사항(기획서, use case, 사용자 스토리), 관련자 대화 ⇒ 도메인 도출

2. 처음에는 전체 윤곽을 알 수 있는 수준으로 개념 모델 작성

3. 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시키기

이때 도메인에 따라 용어 의미가 결정되므로 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안 됨

즉, 모델의 각 구성 요소는 특정 도메인으로 한정할 때 의미가 비로소 완전해지므로 각 하위 도메인마다 별도로 모델을 만들어야 함

<br>

## 도메인 모델 패턴

아키텍처에 관한 것
여기서 도메인 모델은 도메인 계층을 구현할 때 사용하는 객체 모델을 말 함

- **표현 계층** : 사용자(혹은 외부 시스템) 요청 처리, 정보 보여주기

- **응용 계층** : 사용자 요청 기능 실행, 이때 업무 로직 직접 구현하지 않고 도메인 계층 조합해서 기능 실행

- **도메인 계층** :  시스템이 제공할 도메인 규칙 구현

- **인프라스트럭처 계층** : 외부 시스템(DB, 메시징 시스템) 연동

도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴

<img width="608" alt="스크린샷 2024-05-11 오후 5 00 58" src="https://github.com/hongkikii/document/assets/110226866/0dc5f0a2-474a-4e8f-b3e2-4fa7ba5504b0">

> ### 문서화
> 
> 코드를 보면서 도메인을 깊게 이해하게 되므로 코드 자체도 문서화의 대상이 됨
> 
> 도메인 지식이 잘 묻어나도록 코드를 작성하지 않으면 코드의 동작 과정은 해석할 수 있어도,
> 
> 도메인 관점에서 왜 코드를 그렇게 작성했는지 이해하는 데 도움이 되지 않음
> 
> 단순히 코드를 보기 좋게 작성하는 것뿐만 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야
> 
> 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 가짐
>

<br>

## 엔티티

가장 큰 특징 : 식별자를 가짐

도메인 모델의 클래스가 엔티티가 되고, 식별자를 속성으로 가짐

> ### 도메인 모델 엔티티? (vs DB 관계형 모델 엔티티)
> 
> 
> 데이터 뿐만 아니라 도메인 기능을 함께 제공하는 객체
> 
> 1. 도메인 관점에서 기능 구현
> 2. 캡슐화해서 데이터가 임의로 변경되는 것을 막음
> 
> 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있음
>

<br>

## 밸류타입

개념적으로 완전한 하나를 표현할 때

<img width="483" alt="스크린샷 2024-05-11 오후 5 01 08" src="https://github.com/hongkikii/document/assets/110226866/a4f4834e-793f-4bf0-8b21-a660a983e8e1">


ShippingInfo 클래스의 receiverName, receiverPhoneNumber는 서로 다른 데이터를 담고 있지만 개념적으로 **받는 사람**을 의미

<img width="603" alt="스크린샷 2024-05-11 오후 5 13 10" src="https://github.com/hongkikii/document/assets/110226866/b84b2dcd-c91b-40e0-8c9e-8c5d5c9733f8">


따라서 위와 같이 작성 가능

밸류 타입을 사용함으로써 개념적으로 완전한 하나를 잘 표현할 수 있음

꼭 두 개 이상의 데이터를 갖지 않더라도, 의미를 명확하게 표현하기 위해 밸류 타입을 사용하는 경우도 있음

밸류 타입은 밸류 타입을 위한 기능을 추가할 수 있음  

밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다 변경 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호

(두 밸류 객체를 비교할 때는 모든 속성이 같은지 비교)

⇒ 불변 객체 ⇒ 참조 투명성과 스레드에 안전한 특징

<br>

## 아키텍처

<img width="229" alt="스크린샷 2024-05-11 오후 5 36 59" src="https://github.com/hongkikii/document/assets/110226866/5e5a1039-3891-400c-9f41-f5fb883420c8">


상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않음

인프라스트럭처는 논리적 개념이 아닌, 실제 구현 기술들을 뜻함

> ### 만약 응용 계층이 직접 인프라스트럭처 계층에 의존한다면?
> 
> 인프라스트럭처 기술을 이용하지 않고 테스트 불가능, 다른 기술을 이용하려면 코드의 많은 부분을 고쳐야 함
>
> 고수준 => 저수준 의존이 아닌, 저수준 ⇒ 고수준 의존하도록 즉, DIP를 적용해야 함

<img width="441" alt="스크린샷 2024-05-11 오후 5 48 08" src="https://github.com/hongkikii/document/assets/110226866/142d576c-3950-4470-9e76-6a14ffa1e3e1">
<br>
<img width="346" alt="스크린샷 2024-05-11 오후 5 48 38" src="https://github.com/hongkikii/document/assets/110226866/e6a9346d-7cd4-49c9-9487-3f1e27acf32b">
<br>
<img width="383" alt="스크린샷 2024-05-11 오후 5 48 47" src="https://github.com/hongkikii/document/assets/110226866/626bb6b1-5b91-430d-95bd-f1b2acbf2411">


<br>
<br>

## 애그리거트

도메인 내 하위 도메인 존재하는데, 이때 관련 객체를 하나로 묶은 군집을 말함

하위 도메인들끼리 연결되어야 완전한 기능을 구현할 수 있음

ex. 주문 : 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액

애그리거트는 군집에 속한 객체를 관리하는 **루트 엔티티**를 가짐

- 애그리거트가 구현해야 할 기능 제공
  
- 간접적으로 애그리거트 내 다른 엔티티나 밸류 객체에 접근
  
- 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 도움
  
- 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것

애그리거트는 독립된 객체 군이며, 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않음

애그리거트는 복잡한 도메인을 단순한 구조로 만들어 줌

복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력(개발 시간)도 줄어듦

<img width="514" alt="스크린샷 2024-05-11 오후 7 42 27" src="https://github.com/hongkikii/document/assets/110226866/38d9dd33-f0bd-4f9c-baa6-93d571787402">


애그리거트의 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항

- 도메인 규칙에 따라 함께 생성되는 구성 요소는 한 애그리거트에 속할 가능성이 높음
  
- ex. 주문할 상품 개수, 배송지 정보, 주문자 정보 : 주문 시점에 함께 생성
  
- ex. 상품, 상품 리뷰 : 함께 생성되거나 변경되지 않음
  
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함
    - 두 개 이상의 애그리거트를 변경해야 하면, 응용 서비스에서 각 애그리거트의 상태를 변경

리포지토리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의

> ### 애그리거트와 관련된 테이블이 여러개인 경우?
> 애그리거트 루트 매핑 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소의 매핑 테이블에 데이터를 저장해야 함

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면, 애그리거트에 팩토리 메서드를 구현하는 걸 고려할 수 있음

