# 객체
- 하나의 개별적인 실체로 식별 가능한 물리적인 또는 개념적인 사물

- 상태(state), 행동(behavior), 식별자(identity)를 지닌 실체

## 상태
- 상태는 단순한 값(숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓)과 또 다른 객체가 될 수 있다.
  - 단순한 값을 속성(attribute)라고 한다.
  
  - 객체와 객체 사이의 연결을 링크(link)라고 한다.
  - 링크가 존재해야만 요청을 보내고 응답을 받을 수 있다.

- 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다.
- 프로퍼티는 정적이고, 프로퍼티 값(property value)은 동적이다.
- 상태는 변경 가능하다.
- 상태를 변경시키는 건 행동이다.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
  
  - 행동의 순서가 결과에 영향을 미친다. (객체의 행동은 상태에 영향을 받는다)

## 행동
- 객체는 자발적인 행동으로만 상태를 변화시킨다.

- 상태가 있다면 과거의 행동 이력을 파악하지 않아도, 현재를 기반으로 객체의 행동 방식을 예측할 수 있다.  
  (상태를 이용하면 복잡한 객체의 행동을 쉽게 이해할 수 있다)
- 즉, 상태는 행동의 결과로 초래된 부수효과(side effect)를 쉽게 표현하기 위해 도입한 추상적인 개념

## 식별자
- 객체는 어떠한 상태에 있더라도 유일하게 식별 가능하다.

- 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다.
- 이 프로퍼티를 식별자라고 하고, 모든 객체는 식별자를 가진다.
- 반면 단순한 값은 식별자를 가지지 않는다.
- 값(value)은 변하지 않는 양을 모델링한다.
- 즉, 값의 상태는 불변 상태(immutable state)이다.
- 따라서 값은 상태를 이용해 같은지를 판단한다 => 동등성(equality)
- 반면 객체는 시간이나 행동에 따라 변경되는 상태를 포함한다.
- 즉, 객체는 가변 상태(mutable state)이다.
- 따라서 상태와 무관하게 동일한 객체라고 판단할 식별자가 필요하다.
- 객체는 식별자를 이용해 같은지를 판단한다. => 동일성 (identical)

<br>

# 객체지향
- 협력하는 객체들을 말한다.

- 각 객체는 역할, 역할에 따른 책임을 갖고 협력한다.
- 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 요청을 보내는 것이다.
- 즉, 객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다.
- 따라서 행동은 가시적이어야 한다.
- 협력 시 메시지를 통해서만 의사소통할 수 있다.
- 즉, 행동의 결과는 다른 객체에 메시지를 전달하거나 자신의 상태를 변경하는 것이다.
- 상태 변경은 외부에서 알지 못한다. => '캡슐화'
- 메시지 송신자는 단지 자신의 요구를 메시지로 포장해서 전달할 뿐이다.
- 메시지를 해석하고 그에 반응해서 상태를 변경할 지 여부는 전적으로 메시지 수신자의 자율적인 판단이다.
- 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다.
- 자율적인 객체는 스스로 판단, 결정하기 때문에 지능이 높아진다.
- 협력에 참여하는 객체들의 지능이 높아질수록 협력은 유연하고 간결해진다.
> 자율성?
>
객체 지향과 현실 세계의 가장 큰 차이점이다.  

소프트웨어 상품이 실제 세계의 상품을 단순화하거나 추상화한 것이 아니라 특성히 전혀 다른 어떤 것임을 의미한다. 

심지어 현실 세계에서는 존재조차 하지 않는 것들도 소프트웨어 안에서는 생생한 생명을 가진 존재로 재탄생하고,  

오히려 객체지향 세계에는 현실 속의 객체보다 더 많은 특징과 능력을 보유한 객체들로 넘쳐난다.

다만, 창조한 객체의 특성을 상기시킬 수 있다면 현실 속의 객체의 이름을 이용하는 것이 좋다.

이를 제외한다면 객체 지향 세계는 전부 자유롭게 창조되는 새로운 세계이다.

<br>

# 객체지향 설계
- 상태를 중심으로 객체를 바라봐서는 안 된다.

- 객체는 다른 객체와 협력하기 위해 존재한다.
- 따라서, 객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.
- 설계자로서 우리는 협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조해야 한다.
- 결과적으로 애플리케이션 안에서 어떤 행동을 원하느냐가 어떤 객체가 적합한지를 결정한다.

> 상태를 먼저 결정한다면?
> 
1. 캡슐화가 저해된다. 즉, 상태가 공용 인터페이스에 그대로 노출될 확률이 높아진다.
2. 객체를 협력자가 아닌 고립된 섬으로 만든다. ‘협력’이라는 문맥에서 벗어난 설계이기 때문이다.
3. 객체의 재사용성이 저하된다. 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나오기 때문이다.

- 결국은 '협력'이라는 문맥이 가장 중요하다.
- 훌륭한 객체지향 설계자는 객체들 간의 요청과 응답 속에서 창발하는 협력에 초점을 맞춰 애플리케이션을 설계한다.
- 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.

<br>

# 추상화
- 추상화란 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
  
  - 첫번째로 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만든다.
    
  - 두번째로 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만든다.
- 추상화를 할 때는 '정확성'이 아닌 '목적'에 집중해야 한다.
- 추상화의 수준, 이익, 가치는 목적에 의존적이다.
- 어떤 추상화도 의도된 목적이 아닌 다른 목적으로 사용된다면 오도될 수 있다.

## 분류
- 개념(concept), 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념
  
  - 심볼(symbol) : 개념을 가리키는 간략한 이름이나 명칭
    
  - 내연(intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
  - 외연(extension) : 개념에 속하는 모든 객체의 집합(set)
- 개념을 이용하면 객체를 분류(classification)할 수 있다.
- 분류란 객체에 특정한 개념을 적용하는 작업이다.
- 이처럼 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 인스턴스(instance)라고 한다.
- 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.
- 객체를 적절히 분류하지 못한 애플리케이션은 유지보수가 어렵고, 변화에 쉽게 대처하지 못한다.
- 더 중요한 것은 적절한 분류 체계가 애플리케이션을 다루는 개발자의 머릿속에 객체를 쉽게 찾고 조작할 수 있는 정신적인 지도를 제공한다는 것이다.

## 타입
- 개념의 정의와 동일하다.
  
- 데이터 타입
  - 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것
    
  - 즉, 메모리 안에 저장된 0과 1에 대해 수행 가능한 작업과 불가능한 작업을 구분함으로써 데이터가 잘못 사용되는 것을 방지
  - 타입은 데이터가 어떻게 사용되느냐에 관한 것
  - 다만 타입에 속한 데이터를 메모리에 어떻게 표혀나는지는 외부로부터 철저하게 감춰짐
- 객체와 타입
  - 타입은 객체를 분류하는 기준이다.  
  - 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
 
  - 개체의 내부적인 표현은 외부로부터 철저하게 감춰진다.
    - 그 객체가 어떤 데이터를 가지고 있는지는 우리의 관심사가 아니다. => '캡슐화'
      
    - 객체의 내부 표현 방식이 다르더라도, 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다.
      - 동일한 행동 = 동일한 책임 = 동일한 메시지 수신
        
      - 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다.
      - '다형성' : 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
- 일반화(generalization)와 특수화(specialization)
  - 개념의 포함 관계를 나타낸다.
  - 일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가진다.
  - 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다.
  - 객체에서 '상태'가 아닌 '행동'이 기준이 된다. 
  - 슈퍼타입(supertype)과 서브타입(subtype)
- 목적
  - 객체의 동적인 특성을 추상화하는 것이다.
  - 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다.
  > 동적 모델과 정적 모델?
  >
  스냅샷(snapshot), 객체 다이어그램(object diagram) : 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐 => 동적 모델(dynamic model)
  타입 모델(type model) : 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것 => 정적 모델(static model)
  > 클래스?
  >
  타입을 구현할 수 있는 매커니즘 중 하나
  
